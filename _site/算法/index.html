<!DOCTYPE html>
<html>
  <head>
  <title>算法 – 惜余 – 攀上高峰，只为看到心中所想</title>

      <meta charset="utf-8" />
    <meta content='text/html; charset=utf-8' http-equiv='Content-Type'>
    <meta http-equiv='X-UA-Compatible' content='IE=edge'>
    <meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0'>

    
    <meta name="description" content="物理存储结构

  数组
    
      查找：时间复杂度O(1)插入：时间复杂度O(n)
      扩容：把原来的数组长度 x 2
    
  
  链表
    
      查找：时间复杂度O(n)插入：时间复杂度O(1)
    
  



逻辑存储结构
线性结构

  栈
    
      后进先出
    
  
  队列
    
      先进先出
    
  
  哈希表
    
      哈希函数：对Key进行HashCode，得到一个数字下标
      扩容：把原来的数组长度 x 2，重新哈希取模
        非线性结构
      
    
  
  二叉树
    
      二叉排序树:时间复杂度O(logn)最坏情况O(n)
      满二叉树
      完全二叉树
      树的自平衡
        
          红黑树
          AVL树
          树堆
        
      
      遍历
        
          深度优先遍历
            
              前序遍历
                
                  每一个节点，递归实现根-&gt;左节点-&gt;右节点
                
              
              中序遍历
                
                  每一个节点，递归实现左节点-&gt;根-&gt;右节点
                
              
              后序遍历
                
                  每一个节点，递归实现左节点-&gt;右节点-&gt;根
                
              
            
          
          广度优先遍历
            
              层序遍历
                
                  借助队列实现，把树的根节点入队列，如果队列不为空，继续以下过程：①输出当前队列的队首节点，查找该节点的左右节点，如果存在则入队列②重复第一步
                
              
            
          
        
      
    
  
  二叉堆
    
      最大堆、最小堆：插入元素进行比较上浮删除元素进行比较下沉
      优先队列
    
  



排序算法
时间复杂度O(n²)

  冒泡排序
    
      算法过程：
        
          大循环，从第一个元素i遍历到最后一个元素arr.length-1
          小循环，从第一个元素j遍历到最后一个元素arr.length-i-1
          大循环标记是否发生交换isSorted，isSorted为true则结束（优化点：确定是否提前结束循环）
          小循环设置lastExchangeIndex，大循环确定有序边界sortBorder=lastExchangeIndex，j遍历到sortBorder（优化点：确定有序边界）
        
      
      扩展
        
          鸡尾酒排序：1、大循环控制从i到数组最后一个元素的遍历；2、小循环从左遍历到右，然后从右遍历到左
        
      
    
  
  选择排序
  插入排序
  希尔排序



时间复杂度O(nlogn)

  快速排序
    
      算法过程：（核心点分治法）
        
          随机选择一个基准点pivot2、设定left、right指针，如果left != right，则有以下判断：①如果left &lt;= pivot，left++;②如果right &gt; pivot，right–；③都不符合，则把left和right的元素交换；如果left == right，则把left和pivot元素交换，返回left下标；
          把得到的left下标设为基准点pivot，①startIndex，pivot-1的范围再继续做快速排序；②pivot+1、endIndex的范围再继续做快速排序；
          如果startIndex &gt;= endIndex，则结束排序。
        
      
    
  
  归并排序
  堆排序



时间复杂度O(n)

  计数排序
    
      算法过程：1、创建最大数-最小数的范围数组2、遍历数组，把对应下标的数字+13、最后把每个数组元素+前一个数组元素的和作为当前元素的值4、排序数组时，当前元素的值-1
      缺点：1、数据分布不平衡时，会创建很多没有用的数组空间2、不是整数无法采用下标
    
  
  桶排序
    
      算法过程：1、求出最大数、最小数2、根据元素数量创建对应的桶3、遍历原始数组，分配到各个桶，依据算法（每个元素-最小数）* 桶的数量-1 / (最大数-最小数）4、对每个桶的元素进行排序5、遍历桶得到结果
      缺点：1、数据分布不平衡时，一样会存在浪费空间
    
  
  基数排序



面试题
如何判定一个链表是有环链表？

  扩展：1、如何求出环的长度？2、如何求出入环节点？
  算法：
    
      设定两个指针p1、p2，p1指向元素next，p2指向元素next.next
      当p2指向元素不为null，p2.next指向元素不为null，则不停地检测p1，p2所指向元素是否相等，相等则有环
    
  



实现一个栈，该栈带有出栈、入栈、取最小元素3个方法，要保证这3个方法的时间复杂度都是O(1)？

  算法：
    
      栈A存储原始数组，栈B存储最小数
      当出栈时，如果栈A和B的栈顶相同，则栈B出栈，当前栈顶仍然有最小元素
    
  



求出两个整数的最大公约数？

  算法：
    
      碾转相除法
      更相减损术
      更相减损术+移位算术
    
  



如何判断一个数是否为2的整数次幂？

  算法：
    
      num&amp;amp;num-1进行与运算，结果为0则符合
    
  



无序数组排序后的最大相邻差？

  算法：
    
      借助桶排序的算法，每个桶统计最大数和最小数
      比较相邻两个不为空的桶的A、B，B的最小值减去A的最大值，就是最大相邻差
    
  



如何用栈实现队列？

  算法：
    
      栈A实现入队2、栈A弹出栈的元素，作为栈B的入栈数据，栈B出栈实现出队
    
  



找出一个正整数所有数字全排列的下一个数？（核心：字典序算法）

  算法：
    
      假设原始数组A，找出A中倒序的元素下标index
      从A最后一个元素开始比较，比较index-1的元素X，如果X小于最后一个元素，则交换元素
      从A最后一个元素开始比较，比较index的元素Y，如果Y大于最后一个元素，则交换元素输出结果，即为全排列的下一个数
    
  



给出一个整数，删去k个数字后的最小值？（核心：贪心算法）
普通算法：

  把整数用数组A存储
  循环K次，每次把A从左到右比较大小，当左边元素大于右边元素时，则删掉左边的数字
  打印数组得到结果


进阶算法：

  创建一个整数字符串A长度的栈B，得到A.length-K后的新长度L
  遍历A的元素X在栈B入栈3、如果栈B栈顶的元素大于当前A遍历的元素X，则X覆盖栈顶的元素，相当于让B出栈4、找到栈中第一个非零数字的位置Offset，截取栈B从Offset到L的范围数字，得到结果



如何实现大整数相加？



基础算法，持续更新...



" />
    <meta property="og:description" content="物理存储结构

  数组
    
      查找：时间复杂度O(1)插入：时间复杂度O(n)
      扩容：把原来的数组长度 x 2
    
  
  链表
    
      查找：时间复杂度O(n)插入：时间复杂度O(1)
    
  



逻辑存储结构
线性结构

  栈
    
      后进先出
    
  
  队列
    
      先进先出
    
  
  哈希表
    
      哈希函数：对Key进行HashCode，得到一个数字下标
      扩容：把原来的数组长度 x 2，重新哈希取模
        非线性结构
      
    
  
  二叉树
    
      二叉排序树:时间复杂度O(logn)最坏情况O(n)
      满二叉树
      完全二叉树
      树的自平衡
        
          红黑树
          AVL树
          树堆
        
      
      遍历
        
          深度优先遍历
            
              前序遍历
                
                  每一个节点，递归实现根-&gt;左节点-&gt;右节点
                
              
              中序遍历
                
                  每一个节点，递归实现左节点-&gt;根-&gt;右节点
                
              
              后序遍历
                
                  每一个节点，递归实现左节点-&gt;右节点-&gt;根
                
              
            
          
          广度优先遍历
            
              层序遍历
                
                  借助队列实现，把树的根节点入队列，如果队列不为空，继续以下过程：①输出当前队列的队首节点，查找该节点的左右节点，如果存在则入队列②重复第一步
                
              
            
          
        
      
    
  
  二叉堆
    
      最大堆、最小堆：插入元素进行比较上浮删除元素进行比较下沉
      优先队列
    
  



排序算法
时间复杂度O(n²)

  冒泡排序
    
      算法过程：
        
          大循环，从第一个元素i遍历到最后一个元素arr.length-1
          小循环，从第一个元素j遍历到最后一个元素arr.length-i-1
          大循环标记是否发生交换isSorted，isSorted为true则结束（优化点：确定是否提前结束循环）
          小循环设置lastExchangeIndex，大循环确定有序边界sortBorder=lastExchangeIndex，j遍历到sortBorder（优化点：确定有序边界）
        
      
      扩展
        
          鸡尾酒排序：1、大循环控制从i到数组最后一个元素的遍历；2、小循环从左遍历到右，然后从右遍历到左
        
      
    
  
  选择排序
  插入排序
  希尔排序



时间复杂度O(nlogn)

  快速排序
    
      算法过程：（核心点分治法）
        
          随机选择一个基准点pivot2、设定left、right指针，如果left != right，则有以下判断：①如果left &lt;= pivot，left++;②如果right &gt; pivot，right–；③都不符合，则把left和right的元素交换；如果left == right，则把left和pivot元素交换，返回left下标；
          把得到的left下标设为基准点pivot，①startIndex，pivot-1的范围再继续做快速排序；②pivot+1、endIndex的范围再继续做快速排序；
          如果startIndex &gt;= endIndex，则结束排序。
        
      
    
  
  归并排序
  堆排序



时间复杂度O(n)

  计数排序
    
      算法过程：1、创建最大数-最小数的范围数组2、遍历数组，把对应下标的数字+13、最后把每个数组元素+前一个数组元素的和作为当前元素的值4、排序数组时，当前元素的值-1
      缺点：1、数据分布不平衡时，会创建很多没有用的数组空间2、不是整数无法采用下标
    
  
  桶排序
    
      算法过程：1、求出最大数、最小数2、根据元素数量创建对应的桶3、遍历原始数组，分配到各个桶，依据算法（每个元素-最小数）* 桶的数量-1 / (最大数-最小数）4、对每个桶的元素进行排序5、遍历桶得到结果
      缺点：1、数据分布不平衡时，一样会存在浪费空间
    
  
  基数排序



面试题
如何判定一个链表是有环链表？

  扩展：1、如何求出环的长度？2、如何求出入环节点？
  算法：
    
      设定两个指针p1、p2，p1指向元素next，p2指向元素next.next
      当p2指向元素不为null，p2.next指向元素不为null，则不停地检测p1，p2所指向元素是否相等，相等则有环
    
  



实现一个栈，该栈带有出栈、入栈、取最小元素3个方法，要保证这3个方法的时间复杂度都是O(1)？

  算法：
    
      栈A存储原始数组，栈B存储最小数
      当出栈时，如果栈A和B的栈顶相同，则栈B出栈，当前栈顶仍然有最小元素
    
  



求出两个整数的最大公约数？

  算法：
    
      碾转相除法
      更相减损术
      更相减损术+移位算术
    
  



如何判断一个数是否为2的整数次幂？

  算法：
    
      num&amp;amp;num-1进行与运算，结果为0则符合
    
  



无序数组排序后的最大相邻差？

  算法：
    
      借助桶排序的算法，每个桶统计最大数和最小数
      比较相邻两个不为空的桶的A、B，B的最小值减去A的最大值，就是最大相邻差
    
  



如何用栈实现队列？

  算法：
    
      栈A实现入队2、栈A弹出栈的元素，作为栈B的入栈数据，栈B出栈实现出队
    
  



找出一个正整数所有数字全排列的下一个数？（核心：字典序算法）

  算法：
    
      假设原始数组A，找出A中倒序的元素下标index
      从A最后一个元素开始比较，比较index-1的元素X，如果X小于最后一个元素，则交换元素
      从A最后一个元素开始比较，比较index的元素Y，如果Y大于最后一个元素，则交换元素输出结果，即为全排列的下一个数
    
  



给出一个整数，删去k个数字后的最小值？（核心：贪心算法）
普通算法：

  把整数用数组A存储
  循环K次，每次把A从左到右比较大小，当左边元素大于右边元素时，则删掉左边的数字
  打印数组得到结果


进阶算法：

  创建一个整数字符串A长度的栈B，得到A.length-K后的新长度L
  遍历A的元素X在栈B入栈3、如果栈B栈顶的元素大于当前A遍历的元素X，则X覆盖栈顶的元素，相当于让B出栈4、找到栈中第一个非零数字的位置Offset，截取栈B从Offset到L的范围数字，得到结果



如何实现大整数相加？



基础算法，持续更新...



" />
    
    <meta name="author" content="惜余" />

    
    <meta property="og:title" content="算法" />
    <meta property="twitter:title" content="算法" />
    
  <!-- Async font loading -->
<script>
  window.WebFontConfig = {
      custom: {
          families: ['Spoqa Han Sans:100,300,400,700'],
          urls: ['https://spoqa.github.io/spoqa-han-sans/css/SpoqaHanSans-kr.css']
      },
      timeout: 60000
  };
  (function(d) {
      var wf = d.createElement('script'), s = d.scripts[0];
      wf.src = 'https://ajax.googleapis.com/ajax/libs/webfont/1.5.18/webfont.js';
      s.parentNode.insertBefore(wf, s);
  })(document);
</script>

  <!--[if lt IE 9]>
    <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link rel="stylesheet" type="text/css" href="/myblog/style.css" />
  <link rel="alternate" type="application/rss+xml" title="惜余 - 攀上高峰，只为看到心中所想" href="/myblog/feed.xml" />
  <link rel="shortcut icon" href="https://raw.githubusercontent.com/FromEndWorld/LOFFER/master/images/favicon.png">
  <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
  <script src="https://kit.fontawesome.com/56f7faf3f4.js"></script>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
        inlineMath: [['$','$']]
      }
    });
  </script>

  <!-- Created with Jekyll Now - http://github.com/barryclark/jekyll-now -->

</head>

  <body>
    <div class="wrapper-sidebar">
  <header class="sidebar clearfix">
    <div class="site-info">
      
        <a href="/myblog/" class="site-avatar"><img src="https://raw.githubusercontent.com/FromEndWorld/LOFFER/master/images/logo.png" /></a>
       
      <h1 class="site-name"><a href="/myblog/">惜余</a></h1>
      <p class="site-description">攀上高峰，只为看到心中所想</p>
    </div>
  </header>

  <div class="navlist">
    <nav>
      
      
      <a href="/myblog/">首页</a>
      
      
      
      <a href="/myblog/about">关于</a>
      
      
      
      <a href="/myblog/archive">归档</a>
      
      
      
      <a href="/myblog/tags">标签</a>
      
      
    </nav>
  </div>

  <div class="wrapper-footer-desktop">
    <footer class="footer">
      <!-- Refer to https://codepen.io/ruandre/pen/howFi -->
<ul class="svg-icon">

  
  
  

  

  
  <li><a href="mailto:584331125@qq.com" class="icon-8 email" title="Email"><svg viewBox="0 0 512 512"><path d="M502.3 190.8c3.9-3.1 9.7-.2 9.7 4.7V400c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V195.6c0-5 5.7-7.8 9.7-4.7 22.4 17.4 52.1 39.5 154.1 113.6 21.1 15.4 56.7 47.8 92.2 47.6 35.7.3 72-32.8 92.3-47.6 102-74.1 131.6-96.3 154-113.7zM256 320c23.2.4 56.6-29.2 73.4-41.4 132.7-96.3 142.8-104.7 173.4-128.7 5.8-4.5 9.2-11.5 9.2-18.9v-19c0-26.5-21.5-48-48-48H48C21.5 64 0 85.5 0 112v19c0 7.4 3.4 14.3 9.2 18.9 30.6 23.9 40.7 32.4 173.4 128.7 16.8 12.2 50.2 41.8 73.4 41.4z"/></svg><!--[if lt IE 9]><em>Email</em><![endif]--></a></li>
  

  

  

  
  <li><a href="https://github.com/code-huisoido" class="icon-13 github" title="GitHub"><svg viewBox="0 0 512 512"><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg><!--[if lt IE 9]><em>GitHub</em><![endif]--></a></li>
  

  

  

  

  
  <li><a href="/myblog/feed.xml" class="icon-21 rss" title="RSS"><svg viewBox="0 0 512 512"><path d="M400 32H48C21.49 32 0 53.49 0 80v352c0 26.51 21.49 48 48 48h352c26.51 0 48-21.49 48-48V80c0-26.51-21.49-48-48-48zM112 416c-26.51 0-48-21.49-48-48s21.49-48 48-48 48 21.49 48 48-21.49 48-48 48zm157.533 0h-34.335c-6.011 0-11.051-4.636-11.442-10.634-5.214-80.05-69.243-143.92-149.123-149.123-5.997-.39-10.633-5.431-10.633-11.441v-34.335c0-6.535 5.468-11.777 11.994-11.425 110.546 5.974 198.997 94.536 204.964 204.964.352 6.526-4.89 11.994-11.425 11.994zm103.027 0h-34.334c-6.161 0-11.175-4.882-11.427-11.038-5.598-136.535-115.204-246.161-251.76-251.76C68.882 152.949 64 147.935 64 141.774V107.44c0-6.454 5.338-11.664 11.787-11.432 167.83 6.025 302.21 141.191 308.205 308.205.232 6.449-4.978 11.787-11.432 11.787z"/></svg><!--[if lt IE 9]><em>RSS</em><![endif]--></a></li>
  

  

  

  

  

</ul>



<p>海内存知己，天涯若比邻</p>

    </footer>
  </div>
</div>

    

    <div id="main" role="main" class="wrapper-content">
      <div class="container">
        <article class="posts">
  <h1>算法</h1>

  <div clsss="meta">
    <span class="date">
      2019-09-18
    </span>

    <ul class="tag">
      
      <li>
        <a href="http://localhost:4000/myblog/tags#算法">
          算法
        </a>
      </li>
      
      <li>
        <a href="http://localhost:4000/myblog/tags#原创">
          原创
        </a>
      </li>
      
    </ul>
  </div>

  <div class="entry">
    <h2 id="物理存储结构">物理存储结构</h2>
<ul>
  <li>数组
    <ul>
      <li>查找：时间复杂度O(1)插入：时间复杂度O(n)</li>
      <li>扩容：把原来的数组长度 x 2</li>
    </ul>
  </li>
  <li>链表
    <ul>
      <li>查找：时间复杂度O(n)插入：时间复杂度O(1)</li>
    </ul>
  </li>
</ul>

<hr />
<h2 id="逻辑存储结构">逻辑存储结构</h2>
<h3 id="线性结构">线性结构</h3>
<ul>
  <li>栈
    <ul>
      <li>后进先出</li>
    </ul>
  </li>
  <li>队列
    <ul>
      <li>先进先出</li>
    </ul>
  </li>
  <li>哈希表
    <ul>
      <li>哈希函数：对Key进行HashCode，得到一个数字下标</li>
      <li>扩容：把原来的数组长度 x 2，重新哈希取模
        <h3 id="非线性结构">非线性结构</h3>
      </li>
    </ul>
  </li>
  <li>二叉树
    <ul>
      <li>二叉排序树:时间复杂度O(logn)最坏情况O(n)</li>
      <li>满二叉树</li>
      <li>完全二叉树</li>
      <li>树的自平衡
        <ul>
          <li>红黑树</li>
          <li>AVL树</li>
          <li>树堆</li>
        </ul>
      </li>
      <li>遍历
        <ul>
          <li>深度优先遍历
            <ul>
              <li>前序遍历
                <ul>
                  <li>每一个节点，递归实现根-&gt;左节点-&gt;右节点</li>
                </ul>
              </li>
              <li>中序遍历
                <ul>
                  <li>每一个节点，递归实现左节点-&gt;根-&gt;右节点</li>
                </ul>
              </li>
              <li>后序遍历
                <ul>
                  <li>每一个节点，递归实现左节点-&gt;右节点-&gt;根</li>
                </ul>
              </li>
            </ul>
          </li>
          <li>广度优先遍历
            <ul>
              <li>层序遍历
                <ul>
                  <li>借助队列实现，把树的根节点入队列，如果队列不为空，继续以下过程：①输出当前队列的队首节点，查找该节点的左右节点，如果存在则入队列②重复第一步</li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>二叉堆
    <ul>
      <li>最大堆、最小堆：插入元素进行比较上浮删除元素进行比较下沉</li>
      <li>优先队列</li>
    </ul>
  </li>
</ul>

<hr />
<h2 id="排序算法">排序算法</h2>
<h3 id="时间复杂度on">时间复杂度O(n²)</h3>
<ul>
  <li>冒泡排序
    <ul>
      <li>算法过程：
        <ul>
          <li>大循环，从第一个元素i遍历到最后一个元素arr.length-1</li>
          <li>小循环，从第一个元素j遍历到最后一个元素arr.length-i-1</li>
          <li>大循环标记是否发生交换isSorted，isSorted为true则结束（优化点：确定是否提前结束循环）</li>
          <li>小循环设置lastExchangeIndex，大循环确定有序边界sortBorder=lastExchangeIndex，j遍历到sortBorder（优化点：确定有序边界）</li>
        </ul>
      </li>
      <li>扩展
        <ul>
          <li>鸡尾酒排序：1、大循环控制从i到数组最后一个元素的遍历；2、小循环从左遍历到右，然后从右遍历到左</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>选择排序</li>
  <li>插入排序</li>
  <li>希尔排序</li>
</ul>

<hr />
<h3 id="时间复杂度onlogn">时间复杂度O(nlogn)</h3>
<ul>
  <li>快速排序
    <ul>
      <li>算法过程：（核心点分治法）
        <ul>
          <li>随机选择一个基准点pivot2、设定left、right指针，如果left != right，则有以下判断：①如果left &lt;= pivot，left++;②如果right &gt; pivot，right–；③都不符合，则把left和right的元素交换；如果left == right，则把left和pivot元素交换，返回left下标；</li>
          <li>把得到的left下标设为基准点pivot，①startIndex，pivot-1的范围再继续做快速排序；②pivot+1、endIndex的范围再继续做快速排序；</li>
          <li>如果startIndex &gt;= endIndex，则结束排序。</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>归并排序</li>
  <li>堆排序</li>
</ul>

<hr />
<h3 id="时间复杂度on-1">时间复杂度O(n)</h3>
<ul>
  <li>计数排序
    <ul>
      <li>算法过程：1、创建最大数-最小数的范围数组2、遍历数组，把对应下标的数字+13、最后把每个数组元素+前一个数组元素的和作为当前元素的值4、排序数组时，当前元素的值-1</li>
      <li>缺点：1、数据分布不平衡时，会创建很多没有用的数组空间2、不是整数无法采用下标</li>
    </ul>
  </li>
  <li>桶排序
    <ul>
      <li>算法过程：1、求出最大数、最小数2、根据元素数量创建对应的桶3、遍历原始数组，分配到各个桶，依据算法（每个元素-最小数）* 桶的数量-1 / (最大数-最小数）4、对每个桶的元素进行排序5、遍历桶得到结果</li>
      <li>缺点：1、数据分布不平衡时，一样会存在浪费空间</li>
    </ul>
  </li>
  <li>基数排序</li>
</ul>

<hr />
<h2 id="面试题">面试题</h2>
<h3 id="如何判定一个链表是有环链表">如何判定一个链表是有环链表？</h3>
<ul>
  <li>扩展：1、如何求出环的长度？2、如何求出入环节点？</li>
  <li>算法：
    <ul>
      <li>设定两个指针p1、p2，p1指向元素next，p2指向元素next.next</li>
      <li>当p2指向元素不为null，p2.next指向元素不为null，则不停地检测p1，p2所指向元素是否相等，相等则有环</li>
    </ul>
  </li>
</ul>

<hr />
<h3 id="实现一个栈该栈带有出栈入栈取最小元素3个方法要保证这3个方法的时间复杂度都是o1">实现一个栈，该栈带有出栈、入栈、取最小元素3个方法，要保证这3个方法的时间复杂度都是O(1)？</h3>
<ul>
  <li>算法：
    <ul>
      <li>栈A存储原始数组，栈B存储最小数</li>
      <li>当出栈时，如果栈A和B的栈顶相同，则栈B出栈，当前栈顶仍然有最小元素</li>
    </ul>
  </li>
</ul>

<hr />
<h3 id="求出两个整数的最大公约数">求出两个整数的最大公约数？</h3>
<ul>
  <li>算法：
    <ul>
      <li>碾转相除法</li>
      <li>更相减损术</li>
      <li>更相减损术+移位算术</li>
    </ul>
  </li>
</ul>

<hr />
<h3 id="如何判断一个数是否为2的整数次幂">如何判断一个数是否为2的整数次幂？</h3>
<ul>
  <li>算法：
    <ul>
      <li>num&amp;amp;num-1进行与运算，结果为0则符合</li>
    </ul>
  </li>
</ul>

<hr />
<h3 id="无序数组排序后的最大相邻差">无序数组排序后的最大相邻差？</h3>
<ul>
  <li>算法：
    <ul>
      <li>借助桶排序的算法，每个桶统计最大数和最小数</li>
      <li>比较相邻两个不为空的桶的A、B，B的最小值减去A的最大值，就是最大相邻差</li>
    </ul>
  </li>
</ul>

<hr />
<h3 id="如何用栈实现队列">如何用栈实现队列？</h3>
<ul>
  <li>算法：
    <ul>
      <li>栈A实现入队2、栈A弹出栈的元素，作为栈B的入栈数据，栈B出栈实现出队</li>
    </ul>
  </li>
</ul>

<hr />
<h3 id="找出一个正整数所有数字全排列的下一个数核心字典序算法">找出一个正整数所有数字全排列的下一个数？（核心：字典序算法）</h3>
<ul>
  <li>算法：
    <ul>
      <li>假设原始数组A，找出A中倒序的元素下标index</li>
      <li>从A最后一个元素开始比较，比较index-1的元素X，如果X小于最后一个元素，则交换元素</li>
      <li>从A最后一个元素开始比较，比较index的元素Y，如果Y大于最后一个元素，则交换元素输出结果，即为全排列的下一个数</li>
    </ul>
  </li>
</ul>

<hr />
<h3 id="给出一个整数删去k个数字后的最小值核心贪心算法">给出一个整数，删去k个数字后的最小值？（核心：贪心算法）</h3>
<h4 id="普通算法">普通算法：</h4>
<ul>
  <li>把整数用数组A存储</li>
  <li>循环K次，每次把A从左到右比较大小，当左边元素大于右边元素时，则删掉左边的数字</li>
  <li>打印数组得到结果</li>
</ul>

<h4 id="进阶算法">进阶算法：</h4>
<ul>
  <li>创建一个整数字符串A长度的栈B，得到A.length-K后的新长度L</li>
  <li>遍历A的元素X在栈B入栈3、如果栈B栈顶的元素大于当前A遍历的元素X，则X覆盖栈顶的元素，相当于让B出栈4、找到栈中第一个非零数字的位置Offset，截取栈B从Offset到L的范围数字，得到结果</li>
</ul>

<hr />
<h3 id="如何实现大整数相加">如何实现大整数相加？</h3>
<hr />

<div>
<p>基础算法，持续更新...</p>

<image src="/myblog/images/算法.png" />
</div>

  </div>

  
  
<div class="comments">
    <div id="gitalk-container"></div>
    <script>
        const gitalk = new Gitalk({
          clientID: "42a25098aca6e79400e0",
          clientSecret: "044d950524a8011cf8af172efbc0b0155df69be7",
          repo: "myblog",
          owner: "code-huisoido",
          admin: ["code-huisoido"],
          id: decodeURI(location.pathname),      // Ensure uniqueness and length less than 50
          distractionFreeMode: false,  // Facebook-like distraction free mode
          title: "算法",
          language: "zh-CN",

        })
        
        gitalk.render('gitalk-container')
    </script>
</div>

</article>

<div class="pagination">
  
    <span class="prev" >
      <a href="http://localhost:4000/myblog/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/">
        ← 上一篇
      </a>
    </span>
  
  
  
</div>
      </div>
    </div>

    

  </body>

  

  <div class="wrapper-footer-mobile">
    <footer class="footer">
      <!-- Refer to https://codepen.io/ruandre/pen/howFi -->
<ul class="svg-icon">

  
  
  

  

  
  <li><a href="mailto:584331125@qq.com" class="icon-8 email" title="Email"><svg viewBox="0 0 512 512"><path d="M502.3 190.8c3.9-3.1 9.7-.2 9.7 4.7V400c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V195.6c0-5 5.7-7.8 9.7-4.7 22.4 17.4 52.1 39.5 154.1 113.6 21.1 15.4 56.7 47.8 92.2 47.6 35.7.3 72-32.8 92.3-47.6 102-74.1 131.6-96.3 154-113.7zM256 320c23.2.4 56.6-29.2 73.4-41.4 132.7-96.3 142.8-104.7 173.4-128.7 5.8-4.5 9.2-11.5 9.2-18.9v-19c0-26.5-21.5-48-48-48H48C21.5 64 0 85.5 0 112v19c0 7.4 3.4 14.3 9.2 18.9 30.6 23.9 40.7 32.4 173.4 128.7 16.8 12.2 50.2 41.8 73.4 41.4z"/></svg><!--[if lt IE 9]><em>Email</em><![endif]--></a></li>
  

  

  

  
  <li><a href="https://github.com/code-huisoido" class="icon-13 github" title="GitHub"><svg viewBox="0 0 512 512"><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg><!--[if lt IE 9]><em>GitHub</em><![endif]--></a></li>
  

  

  

  

  
  <li><a href="/myblog/feed.xml" class="icon-21 rss" title="RSS"><svg viewBox="0 0 512 512"><path d="M400 32H48C21.49 32 0 53.49 0 80v352c0 26.51 21.49 48 48 48h352c26.51 0 48-21.49 48-48V80c0-26.51-21.49-48-48-48zM112 416c-26.51 0-48-21.49-48-48s21.49-48 48-48 48 21.49 48 48-21.49 48-48 48zm157.533 0h-34.335c-6.011 0-11.051-4.636-11.442-10.634-5.214-80.05-69.243-143.92-149.123-149.123-5.997-.39-10.633-5.431-10.633-11.441v-34.335c0-6.535 5.468-11.777 11.994-11.425 110.546 5.974 198.997 94.536 204.964 204.964.352 6.526-4.89 11.994-11.425 11.994zm103.027 0h-34.334c-6.161 0-11.175-4.882-11.427-11.038-5.598-136.535-115.204-246.161-251.76-251.76C68.882 152.949 64 147.935 64 141.774V107.44c0-6.454 5.338-11.664 11.787-11.432 167.83 6.025 302.21 141.191 308.205 308.205.232 6.449-4.978 11.787-11.432 11.787z"/></svg><!--[if lt IE 9]><em>RSS</em><![endif]--></a></li>
  

  

  

  

  

</ul>



<p>海内存知己，天涯若比邻</p>

    </footer>


</html>
